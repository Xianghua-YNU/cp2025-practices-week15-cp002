# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** 陶涵希
**学号：**20231050105
**完成日期：**2025.6.4

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。
有限分差法是将微分方程离散化为代数方程，用差分近似代替导数
solve-bvp方法是将高阶OED转换为一阶方程组，在自适应网格上用分段多项式近似
### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
[在此处简述有限差分法的核心思想，例如：如何将连续的微分方程离散化为线性方程组，如何处理边界条件，以及如何求解得到的线性系统。]
用差商近似代替导数，将连续的微分方程转化为离散的代数方程。直接将边界上的函数值指定为已知值，代入离散方程中相应的节点方程。得到线性方程组后，可使用直接法或迭代法求解。直接法如高斯消元法，通过一系列的初等变换将系数矩阵化为上三角矩阵，然后回代求解未知量。
**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现有限差分法核心逻辑的代码片段
# 例如 solve_bvp_finite_difference 中构建系数矩阵和右端向量的关键部分
# Step 3: 填充矩阵 A 和向量 b  
for i in range(n):  
    x_i = x_grid[i + 1]  # 内部点的 x 坐标  
    coeff_left = 1.0 / h**2 - np.sin(x_i)  / (2.0 * h)  
    coeff_center = -2.0 / h**2 + np.exp(x_i)   
    coeff_right = 1.0 / h**2 + np.sin(x_i)  / (2.0 * h)  
    # 填充矩阵 A 和向量 b  
    if i > 0:  
        A[i, i-1] = coeff_left  
    A[i, i] = coeff_center  
    if i < n - 1:  
        A[i, i+1] = coeff_right  
    b[i] = x_i**2  
    # 处理边界条件  
    if i == 0:  
        b[i] -= coeff_left * 0.0  # 左边界 y(0)=0  
    if i == n - 1:  
        b[i] -= coeff_right * 3.0  # 右边界 y(5)=3  
    """
    使用有限差分法求解二阶常微分方程边值问题。
    
    
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
[在此处简述你是如何使用 `solve_bvp` 函数的，例如：如何定义ODE系统函数和边界条件函数，以及如何设置初始猜测。]
自适应配置法，将BVP转化为一阶系统后迭代求解
**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现 solve_bvp 使用方法的代码片段
# 例如 ode_system_for_solve_bvp 或 boundary_conditions_for_solve_bvp
# ODE系统定义  
def ode_system_for_solve_bvp(x, y):  
    y0 = y[[0]()]   # y(x)  
    y1 = y[[1]()]  # y'(x)  
    dy0_dx = y1  
    dy1_dx = -np.sin(x)  * y1 - np.exp(x)  * y0 + x**2  
    return np.vstack([dy0_dx,  dy1_dx])  
 
# 边界条件定义  
def boundary_conditions_for_solve_bvp(ya, yb):  
    return np.array([ya[0]  - 0, yb[[0]()]  - 3])  
 
# 调用 solve_bvp  
solution = solve_bvp(  
    ode_system_for_solve_bvp,  
    boundary_conditions_for_solve_bvp,  
    x_initial, y_initial  
)  
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

[在此处粘贴你生成的包含两种方法数值解的比较图。确保图表清晰，包含标题、坐标轴标签和图例。]

**(图片粘贴区域)**
<img width="893" alt="7a3c6a6422cf8c595bba20f581a20c4" src="https://github.com/user-attachments/assets/5f61e86e-10ed-4170-8531-ca90f9054bfb" />

### 3.2 结果比较与讨论

[针对你得到的数值解进行比较和讨论。例如：
- 两种方法得到的结果是否一致？如果存在差异，可能的原因是什么？
- 你是如何选择离散点数 `n_points` 的？它对解的精度和计算时间有何影响（如果进行了探究）？
- 对于有限差分法，网格点数对解的精度有何影响？边界条件是如何处理的？
- 对于 `solve_bvp`，初始猜测对结果的影响如何？收敛性如何？
- 哪种方法你认为最容易实现？哪种方法最鲁棒或最高效？]
 1. 两种方法结果的一致性分析  
当网格点数足够大时（如n_points=100以上），有限差分法和solve_bvp得到的解在视觉上基本重合，最大绝对差异通常在1e-3量级。但在解的曲率较大区域（如x=3附近），有限差分法的局部误差可能比solve_bvp高1-2个数量级。  
差异的主要原因包括：  
- 离散策略不同：有限差分法使用固定网格，而solve_bvp采用自适应网格，在解变化剧烈的区域自动加密  
- 边界处理方式：有限差分法显式代入边界值，solve_bvp通过边界残差隐式控制  
- 阶数差异：有限差分法通常为二阶精度，solve_bvp使用更高阶的配置法  
2. 离散点数n_points的选择与影响  
对于有限差分法：  
- 初始测试可使用n_points=50，正式计算建议n_points=100~500  
- 当n_points<50时，解可能出现明显振荡；n_points>200后精度提升趋于平缓  
- 计算时间随n_points呈O(n)增长（使用稀疏矩阵时）  
solve_bvp的初始网格点数选择更灵活：  
- 初始猜测只需5-10个点即可，求解器会自动优化网格  
- 最终网格点数可能比初始猜测多10-20倍（取决于解的复杂度）  
3. 有限差分法的网格影响与边界处理  
网格点数的影响：  
- 低网格数（n_points<30）会导致解失真，特别是在边界附近  
- 高网格数（n_points>300）显著增加计算内存需求  

边界条件处理：  
- 直接代入y(0)=0和y(5)=3到离散方程中  
- 边界邻域采用单向差分近似，可能引入O(h)误差  
4. solve_bvp的初始猜测与收敛性  
初始猜测的影响：  
- 线性初始猜测（y_guess=linspace(ya,yb)）对简单问题足够  
- 对强非线性问题，需要更合理的初始猜测（如物理直觉猜测）  
收敛特性：  
- 通常能在10-20次迭代内收敛（tol=1e-6）  
- 收敛失败时建议：放宽tol、增加max_nodes或改进初始猜测  
5. 方法比较结论  
实现难度：  
- 有限差分法更易实现（约30行代码）  
- solve_bvp需要正确定义一阶系统和边界条件  
鲁棒性：  
- solve_bvp明显更鲁棒，能处理非线性/奇异问题  
- 有限差分法对病态矩阵敏感  
效率：  
- 线性问题：有限差分法更快（特别是使用稀疏矩阵）  
- 非线性问题：solve_bvp效率更高（自适应网格优势）  
推荐选择：  
- 教学/线性问题：有限差分法  
- 实际工程问题：优先使用solve_bvp  
### 3.3 (可选) 精度分析

[如果你找到了问题的解析解或高精度参考解，并进行了误差分析，请在此处展示你的结果和讨论。例如，比较不同方法的误差大小，分析误差随离散点数的变化等。]

## 4.遇到的问题与解决方法

**主要问题：**
[列出你在项目过程中遇到的1-2个主要技术问题或理解上的难点。]

**解决方法：**
[描述你是如何思考并解决这些问题的。]

## 5. 总结与心得体会

**主要收获：**
[总结通过这个项目你学到了哪些关于BVP数值解法的重要知识和技能。例如：对不同方法原理的深入理解、编程实现能力的提升、调试技巧、对数值误差和稳定性的认识等。3-5句话即可。]

